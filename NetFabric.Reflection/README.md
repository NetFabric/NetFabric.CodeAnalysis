# NetFabric.Reflection

This package extends the reflection API.

## IsEnumerable() and IsAsyncEnumerable()

To find if a type is enumerable, it's not enough to check if it implements `IEnumerable`, `IEnumerable<>`, or `IAsyncEnumerable<>`. `foreach` and `await foreach` support several other cases. Use the methods `IsEnumerable` and `IsAsyncEnumerable` instead:

```csharp
using NetFabric.Reflection;

var isEnumerable = type.IsEnumerable(out var enumerableInfo, out var errors);

var isAsyncEnumerable = type.IsAsyncEnumerable(out var asyncEnumerableInfo, out var errors);
```

The methods return a boolean value indicating if it's a valid enumerable or enumerator. It does not support the cases where `GetEnumerator()` or `GetAsyncEnumerator()` are provided as extension methods as it's not possible to find extension methods by using reflection.

If `true`, the first output parameter contains [`MethodInfo`](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodinfo) for the method `GetEnumerator`/`GetAsynEnumerator` of the enumerable, the property `Current` and the method `MoveNext`/`MoveNextAsync` of the enumerator, following the precedences used by Roslyn for the `foreach` and `await foreach` keywords. It may also contain for methods `Reset` and `Dispose`/`DisposeAsync` if defined.

If `false`, the second output parameter indicates what error was found. It can be a missing `GetEnumerator()`, missing `Current`, or missing `MoveNext()`.

## ExpressionEx

[NetFabric.Reflection](https://www.nuget.org/packages/NetFabric.Reflection/) contains high level `Expression` generators that makes it easier to handle enumerables in [Expression Trees](https://tyrrrz.me/blog/expression-trees). The code generated is as similar as possible to the one generated by Roslyn for the equivalent keywords.

To use these, add the [NetFabric.Reflection](https://www.nuget.org/packages/NetFabric.Reflection/) package to your project.

### ExpressionEx.ForEach

```csharp
public static Expression ForEach(Expression enumerable, Func<Expression, Expression> body)
```

-   `enumerable` - Defines an enumerable.
-   `body` - Defines the body containing the code performed for each item. Pass a lambda expression that, given an `Expression` that defines an item, returns an `Expression` that uses it.

**WARNING:** Async enumerables are not supported.

The `Expression` generated depends on:

-   Whether the enumerator is an `interface`, `class`, `struct`, or `ref struct`.
-   Whether the enumerator is disposable or not.
-   Whether the enumerable is an array. In this case, it uses the array indexer instead of `IEnumerable<>` to enumerate.

Throws an exception if the `Expression` in the first parameter does not define an enumerable. In case you don't want the exception to be thrown, use the other overload that takes an `EnumerableInfo` or `EnumerableSymbols` for the first parameter. Use `IsEnumerable` to get the required values.

Here's an example, using `ExpressionEx.ForEach`, that calculates the sum of the items in an enumerable:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum<TEnumerable>(TEnumerable enumerable)
{
    var enumerableParameter = Parameter(typeof(TEnumerable), "enumerable");
    var sumVariable = Variable(typeof(int), "sum");
    var expression = Block(
        new[] {sumVariable},
        Assign(sumVariable, Constant(0)),
        ForEach(
            enumerableParameter,
            item => AddAssign(sumVariable, item)),
        sumVariable);
    var sum = Lambda<Func<TEnumerable, int>>(expression, enumerableParameter).Compile();

    return sum(enumerable);
}
```

### ExpressionEx.For

```csharp
public static Expression For(Expression initialization, Expression condition, Expression iterator, Expression body)
```

-   `initialization` - Defines the initialization. Performed before starting the loop iteration.
-   `condition` - Defines the condition. Performed before each loop iteration.
-   `iterator` - Defines the iterator. Performed after each loop iteration.
-   `body` - Defines the body. Performed in each loop iteration.

`ExpressionEx.For` does not declare the iteration variable. You may have to declare it using an `Expression.Block`.

Here's an example, using `ExpressionEx.For`, that calculates the sum of the items in an array:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum(int[] array, int start, int end)
{
    var arrayParameter = Parameter(typeof(int[]), "array");
    var startParameter = Parameter(typeof(int), "start");
    var endParameter = Parameter(typeof(int), "end");
    var indexVariable = Variable(typeof(int), "index");
    var sumVariable = Variable(typeof(int), "sum");
    var expression = Block(
        new[] { indexVariable, sumVariable },
        Assign(sumVariable, Constant(0)),
        For(
            Assign(indexVariable, startParameter),
            LessThan(indexVariable, endParameter),
            PostIncrementAssign(indexVariable),
            AddAssign(sumVariable, ArrayIndex(arrayParameter, indexVariable))),
        sumVariable);
    var sum = Lambda<Func<int[], int, int, int>>(expression, arrayParameter, startParameter, endParameter).Compile();

    return sum(array, start, end);
}
```

### ExpressionEx.While

```csharp
public static LoopExpression While(Expression condition, Expression body)
```

-   `condition` - Defines the condition. Performed before each loop iteration.
-   `body` - Defines the body. Performed in each loop iteration.

Here's an example, using `ExpressionEx.While`, that calculates the sum of the items in an array:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum(int[] array, int start, int end)
{
    var valueParameter = Parameter(typeof(int[]), "value");
    var startParameter = Parameter(typeof(int), "start");
    var endParameter = Parameter(typeof(int), "end");
    var sumVariable = Variable(typeof(int), "sum");
    var indexVariable = Variable(typeof(int), "index");
    var expression = Block(
        new[] { indexVariable, sumVariable },
        Assign(sumVariable, Constant(0)),
        Assign(indexVariable, startParameter),
        While(
            LessThan(indexVariable, endParameter),
            Block(
                AddAssign(sumVariable, ArrayIndex(valueParameter, indexVariable)),
                PostIncrementAssign(indexVariable)
            )
        ),
        sumVariable);
    var sum = Lambda<Func<int[], int, int, int>>(expression, valueParameter, startParameter, endParameter).Compile();

    return sum(array, start, end);
}
```

### ExpressionEx.Using

```csharp
public static TryExpression Using(ParameterExpression instance, Expression body)
```

-   `instance` - Defines the variable to be disposed.
-   `body` - Defines the body after which the variable is disposed.

Throws and exception if the variable is not disposable. To be considered disposable, if it's is a `class` or a `struct`, it has to implement the [`IDisposable`](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable) interface. If it's a `ref struct`, it only needs to have a public parameterless `Dispose`.

`ExpressionEx.Using` does not declare the iteration variable. You may have to declare it using an `Expression.Block`.

**WARNING:** `IAsyncDisposable` is not supported.

Here's an example, using `ExpressionEx.Using`, that calculates the sum of the items in an enumerable:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum<TEnumerable>(TEnumerable enumerable)
{
    if (!typeof(TEnumerable).IsEnumerable(out var enumerableInfo))
        throw new Exception("Not an enumerable!");

    var enumerableParameter = Parameter(typeof(TEnumerable), "enumerable");
    var enumeratorVariable = Variable(enumerableInfo.GetEnumerator.ReturnType, "enumerator");
    var sumVariable = Variable(typeof(int), "sum");
    var expression = Block(
        new[] {enumeratorVariable, sumVariable},
        Assign(enumeratorVariable, Call(enumerableParameter, enumerableInfo.GetEnumerator)),
        Assign(sumVariable, Constant(0)),
        Using(
            enumeratorVariable,
            While(
                Call(enumeratorVariable, enumerableInfo.EnumeratorInfo.MoveNext),
                AddAssign(sumVariable, Call(enumeratorVariable, enumerableInfo.EnumeratorInfo.GetCurrent))
            )
        ),
        sumVariable);
    var sum = Lambda<Func<TEnumerable, int>>(expression, enumerableParameter).Compile();

    return sum(enumerable);
}
```
