# NetFabric.Reflection

This package extends the reflection API.

## Enumerable type checking

To find if a type is enumerable, it's not enough to check if it implements `IEnumerable`, `IEnumerable<>` or `IAsyncEnumerable<>`. The `foreach` and `await foreach` statements support several other cases.

> NOTE: Check the article ["Efficient Data Processing: Leveraging C#'s foreach Loop"](https://www.linkedin.com/pulse/efficient-data-processing-leveraging-cs-foreach-loop-ant%C3%A3o-almada/) to understand all the possible cases supported by the `foreach` statement.

This package provides extension methods for the type `Type` that can correctly validate if the type it represents can be used as the source in `foreach` or `await foreach` statements.

### IsEnumerable

```csharp
public static bool IsEnumerable(this Type type,
    [NotNullWhen(true)] out EnumerableInfo? enumerableInfo,
    out IsEnumerableError error);
```

The method returns `true` if the type represented by `Type` can be used in a `foreach` statement; otherwise `false`.

> NOTE: It does not support the case when `GetEnumerator()` is defined as an extension method. It's not possible to find extension methods using reflection.

If it returns `true`, the `enumerableInfo` output parameter contains all the `MethodInfo` and `PropertySymbol` for the methods and properties that are going to be actually used by the `foreach` statement. The `GetEnumerator()` of the enumerable, the property `Current` and the method `MoveNext()` of the enumerator. It may also contain info for methods `Reset()` and `Dispose()` of the enumerator, if defined.

If it returns `false`, the `error` output parameter indicates why the type is not considered an enumerable. It can be `MissingGetEnumerator`, `MissingCurrent` or `MissingMoveNext`.

The output parameter also includes a `ForEachUsesIndexer` boolean property that indicates that, although the collection provides an enumerator, `foreach` will use the indexer instead. That's the case for arrays and spans.

You can use these info values to further validate the enumerable and its respective enumerator. For example, use the following to find if the `Current` property of the enumerator returns by reference:

```csharp
enumerableInfo.EnumeratorSymbols.Current.ReturnsByRef;
```

### IsAsyncEnumerable

```csharp
public static bool IsAsyncEnumerable(this Type type,
    [NotNullWhen(true)] out AsyncEnumerableInfo? enumerableInfo,
    out IsAsyncEnumerableError error);
```

The methods returs `true` if the type represented by `Type` can be used in an `await foreach` statement; otherwise `false`.

> NOTE: It does not support the case when `GetAsyncEnumerator()` is defined as an extension method. It's not possible to find extension methods using reflection.

If it returns `true`, the `enumerableInfo` output parameter contains all the `MethodInfo` and `PropertySymbol` for the methods and properties that are going to be actually used by the `await foreach` statement. The `GetAsyncEnumerator()` of the enumerable, the property `Current` and the method `MoveNextAsync()` of the enumerator. It may also contain info for method `DisposeAsync()` of the enumerator, if defined.

If it returns `false`, the `error` output parameter indicates why the type is not considered an enumerable. It can be `MissingAsyncGetEnumerator`, `MissingCurrent` or `MissingMoveNextAsync`.

You can use these info values to further validate the async enumerable or its respective enumerator.

## Expression trees

[NetFabric.Reflection](https://www.nuget.org/packages/NetFabric.Reflection/) contains high level `Expression` generators that makes it easier to handle enumerables in [Expression Trees](https://tyrrrz.me/blog/expression-trees). The code generated is as similar as possible to the one generated by Roslyn for the equivalent keywords.

To use these, add the [NetFabric.Reflection](https://www.nuget.org/packages/NetFabric.Reflection/) package to your project.

### ExpressionEx.ForEach

```csharp
public static Expression ForEach(Expression enumerable, Func<Expression, Expression> body)
```

-   `enumerable` - Defines an enumerable.
-   `body` - Defines the body containing the code performed for each item. Pass a lambda expression that, given an `Expression` that defines an item, returns an `Expression` that uses it.

**WARNING:** Async enumerables are not supported.

The `Expression` generated depends on:

-   Whether the enumerator is an `interface`, `class`, `struct`, or `ref struct`.
-   Whether the enumerator is disposable or not.
-   Whether the enumerable is an array. In this case, it uses the array indexer instead of `IEnumerable<>` to enumerate.

Throws an exception if the `Expression` in the first parameter does not define an enumerable. In case you don't want the exception to be thrown, use the other overload that takes an `EnumerableInfo` or `EnumerableSymbols` for the first parameter. Use `IsEnumerable` to get the required values.

Here's an example, using `ExpressionEx.ForEach`, that calculates the sum of the items in an enumerable:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum<TEnumerable>(TEnumerable enumerable)
{
    var enumerableParameter = Parameter(typeof(TEnumerable), "enumerable");
    var sumVariable = Variable(typeof(int), "sum");
    var expression = Block(
        new[] {sumVariable},
        Assign(sumVariable, Constant(0)),
        ForEach(
            enumerableParameter,
            item => AddAssign(sumVariable, item)),
        sumVariable);
    var sum = Lambda<Func<TEnumerable, int>>(expression, enumerableParameter).Compile();

    return sum(enumerable);
}
```

### ExpressionEx.For

```csharp
public static Expression For(Expression initialization, Expression condition, Expression iterator, Expression body)
```

-   `initialization` - Defines the initialization. Performed before starting the loop iteration.
-   `condition` - Defines the condition. Performed before each loop iteration.
-   `iterator` - Defines the iterator. Performed after each loop iteration.
-   `body` - Defines the body. Performed in each loop iteration.

`ExpressionEx.For` does not declare the iteration variable. You may have to declare it using an `Expression.Block`.

Here's an example, using `ExpressionEx.For`, that calculates the sum of the items in an array:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum(int[] array, int start, int end)
{
    var arrayParameter = Parameter(typeof(int[]), "array");
    var startParameter = Parameter(typeof(int), "start");
    var endParameter = Parameter(typeof(int), "end");
    var indexVariable = Variable(typeof(int), "index");
    var sumVariable = Variable(typeof(int), "sum");
    var expression = Block(
        new[] { indexVariable, sumVariable },
        Assign(sumVariable, Constant(0)),
        For(
            Assign(indexVariable, startParameter),
            LessThan(indexVariable, endParameter),
            PostIncrementAssign(indexVariable),
            AddAssign(sumVariable, ArrayIndex(arrayParameter, indexVariable))),
        sumVariable);
    var sum = Lambda<Func<int[], int, int, int>>(expression, arrayParameter, startParameter, endParameter).Compile();

    return sum(array, start, end);
}
```

### ExpressionEx.While

```csharp
public static LoopExpression While(Expression condition, Expression body)
```

-   `condition` - Defines the condition. Performed before each loop iteration.
-   `body` - Defines the body. Performed in each loop iteration.

Here's an example, using `ExpressionEx.While`, that calculates the sum of the items in an array:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum(int[] array, int start, int end)
{
    var valueParameter = Parameter(typeof(int[]), "value");
    var startParameter = Parameter(typeof(int), "start");
    var endParameter = Parameter(typeof(int), "end");
    var sumVariable = Variable(typeof(int), "sum");
    var indexVariable = Variable(typeof(int), "index");
    var expression = Block(
        new[] { indexVariable, sumVariable },
        Assign(sumVariable, Constant(0)),
        Assign(indexVariable, startParameter),
        While(
            LessThan(indexVariable, endParameter),
            Block(
                AddAssign(sumVariable, ArrayIndex(valueParameter, indexVariable)),
                PostIncrementAssign(indexVariable)
            )
        ),
        sumVariable);
    var sum = Lambda<Func<int[], int, int, int>>(expression, valueParameter, startParameter, endParameter).Compile();

    return sum(array, start, end);
}
```

### ExpressionEx.Using

```csharp
public static TryExpression Using(ParameterExpression instance, Expression body)
```

-   `instance` - Defines the variable to be disposed.
-   `body` - Defines the body after which the variable is disposed.

Throws and exception if the variable is not disposable. To be considered disposable, if it's is a `class` or a `struct`, it has to implement the [`IDisposable`](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable) interface. If it's a `ref struct`, it only needs to have a public parameterless `Dispose`.

`ExpressionEx.Using` does not declare the iteration variable. You may have to declare it using an `Expression.Block`.

**WARNING:** `IAsyncDisposable` is not supported.

Here's an example, using `ExpressionEx.Using`, that calculates the sum of the items in an enumerable:

```csharp
using static NetFabric.Expressions.ExpressionEx;
using static System.Linq.Expressions.Expression;

int Sum<TEnumerable>(TEnumerable enumerable)
{
    if (!typeof(TEnumerable).IsEnumerable(out var enumerableInfo))
        throw new Exception("Not an enumerable!");

    var enumerableParameter = Parameter(typeof(TEnumerable), "enumerable");
    var enumeratorVariable = Variable(enumerableInfo.GetEnumerator.ReturnType, "enumerator");
    var sumVariable = Variable(typeof(int), "sum");
    var expression = Block(
        new[] {enumeratorVariable, sumVariable},
        Assign(enumeratorVariable, Call(enumerableParameter, enumerableInfo.GetEnumerator)),
        Assign(sumVariable, Constant(0)),
        Using(
            enumeratorVariable,
            While(
                Call(enumeratorVariable, enumerableInfo.EnumeratorInfo.MoveNext),
                AddAssign(sumVariable, Call(enumeratorVariable, enumerableInfo.EnumeratorInfo.GetCurrent))
            )
        ),
        sumVariable);
    var sum = Lambda<Func<TEnumerable, int>>(expression, enumerableParameter).Compile();

    return sum(enumerable);
}
```
